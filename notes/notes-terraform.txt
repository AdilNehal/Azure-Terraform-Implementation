first I use this:

locals {
  user_information = nonsensitive(data.vault_generic_secret.user_information.data)

}

then looping like: 

module "azure_user" {
  source = "./modules/users"
  for_each = local.user_information

  display_name          = each.value.display_name
  user_principal_name   = each.value.user_principal_name
  password              = each.value.password
  force_password_change = var.force_password_change
}

but it was giving me:

  ╷
  │ Error: Unsupported attribute
  │ 
  │   on main.tf line 10, in module "azure_user":
  │   10:   display_name          = each.value.display_name
  │     ├────────────────
  │     │ each.value is "{\"display_name\":\"had\",\"password\":\"value321\",\"user_principal_name\":\"had@adilnehal65gmail.onmicrosoft.com\"}"
  │ 
  │ Can't access attributes on a primitive-typed value (string).
  ╵

Because:

Vault is giving a map of strings, where each string is itself a JSON blob. That’s why Terraform says each.value is a primitive string and not an object. LIKE:

{
  "alicebob" = "{\"display_name\":\"alicebob\",\"password\":\"value321\",\"user_principal_name\":\"alicebob@adilnehal65gmail.onmicrosoft.com\"}"
}


So before looping, we need to jsondecode each value.

locals {
  raw_user_information = nonsensitive(data.vault_generic_secret.user_information.data)

  # Decode each JSON string into a map/object
  user_information = {
    for k, v in local.raw_user_information :
    k => jsondecode(v)
  }
}

Now each.value is a proper object with attributes (display_name, password, user_principal_name) instead of just a JSON string.


for_each = { for group in var.groups : group.group_name => group }

variables.tf
"groups" { 
  description = "list of groups to create with their properties" 
  type = list(any) 
} 

tfvars

groups = [
  {
    group_name   = "Security Admins"
    description  = "Security Administrators Group"
  }
]

for group in var.groups — iterate
This starts a for expression that iterates the list. On each iteration group is one element of the list (the object).

group.group_name => group — create a map entry
For each group we build a key/value pair where:

key = group.group_name (a string, "Security Admins"), and

value = the whole group object.

Result — a map
The for expression returns this map:

{
  "Security Admins" = {
    group_name  = "Security Admins"
    description = "Security Administrators Group"
  }
}


That map is what you assign to for_each. Terraform will create one instance for each map entry. Inside the resource/module:

each.key → "Security Admins"

each.value → { group_name = "Security Admins", description = "..." }

------

why we flatten first? 

  memberships = flatten([
    for gm in var.group_membership : [
      for member in gm.member_names : {
        group_name = gm.group_name
        member     = member
      }
    ]
  ])

let's see my variables:

group_membership = [
  {
    group_name   = "Security Admins"
    member_names = ["alice@contoso.com", "bob@contoso.com"]
  },
  {
    group_name   = "Readers"
    member_names = ["carol@contoso.com"]
  }
]

Without flatten

If we just for gm in var.group_membership : [...], we’d get a list of lists:

[
  [ # first group
    { group_name = "Security Admins", member = "alice@contoso.com" },
    { group_name = "Security Admins", member = "bob@contoso.com" }
  ],
  [ # second group
    { group_name = "Readers", member = "carol@contoso.com" }
  ]
]

it’s a nested list (list(list(object(...)))).

Why we flatten

Terraform’s for_each in a resource needs a flat map or set, not a list of lists.
So we flatten to turn it into a single list:

[
  { group_name = "Security Admins", member = "alice@contoso.com" },
  { group_name = "Security Admins", member = "bob@contoso.com" },
  { group_name = "Readers",         member = "carol@contoso.com" }
]

Then we convert to a map
for_each = {
  for m in local.memberships : "${m.group_name}-${m.member}" => m
}


This makes a clean map for for_each like:

{
  "Security Admins-alice@contoso.com" = { group_name = "Security Admins", member = "alice@contoso.com" }
  "Security Admins-bob@contoso.com"   = { group_name = "Security Admins", member = "bob@contoso.com" }
  "Readers-carol@contoso.com"         = { group_name = "Readers", member = "carol@contoso.com" }
}

group_object_id = lookup(module.azure_groups.group_details, each.value.group_name) 
member_object_id = lookup(module.azure_user.user_details, each.value.member)

& why this?

What you already have

Your modules export two maps:

Groups
output "group_details" {
  value = {
    "Security Admins" = "11111111-1111-1111-1111-111111111111"
    "Readers"         = "22222222-2222-2222-2222-222222222222"
  }
}

Users
output "user_details" {
  value = {
    "alice@contoso.com" = "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
    "bob@contoso.com"   = "bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb"
    "carol@contoso.com" = "cccccccc-cccc-cccc-cccc-cccccccccccc"
  }
}

What azuread_group_member needs

The resource requires object IDs:

resource "azuread_group_member" "this" {
  group_object_id  = <GUID of the group>
  member_object_id = <GUID of the user>
}


But in your group_membership variable, you’re passing names / UPNs (e.g. "Security Admins", "alice@contoso.com").

So you need a lookup step:

Take each.value.group_name (like "Security Admins") → find its ID in module.azure_groups.group_details

Take each.value.member (like "alice@contoso.com") → find its ID in module.azure_user.user_details

Why lookup()

We could technically do:

module.azure_groups.group_details[each.value.group_name]
module.azure_user.user_details[each.value.member]


But that would throw an error if the key doesn’t exist.

Using lookup(map, key) is safer:

Returns the value if found

Optionally, you can give a default if not found (e.g. lookup(map, key, null))